package com.bombbird.terminalcontrol2.traffic

import com.badlogic.ashley.core.Entity
import com.badlogic.ashley.utils.ImmutableArray
import com.bombbird.terminalcontrol2.components.*
import com.bombbird.terminalcontrol2.entities.WakeZone
import com.bombbird.terminalcontrol2.global.GAME
import com.bombbird.terminalcontrol2.global.MAX_ALT
import com.bombbird.terminalcontrol2.global.VERT_SEP
import com.bombbird.terminalcontrol2.traffic.conflict.Conflict
import com.bombbird.terminalcontrol2.utilities.calculateDistanceBetweenPoints
import com.bombbird.terminalcontrol2.utilities.pxToNm
import ktx.ashley.get
import ktx.ashley.has
import ktx.collections.GdxArray
import kotlin.math.ceil
import kotlin.math.floor
import kotlin.math.roundToInt

/** Helper class for managing wake separation between entities */
class WakeManager {

    private val startingAltitude = floor(getLowestAirportElevation() / VERT_SEP).roundToInt() * VERT_SEP
    val wakeLevels = Array<GdxArray<WakeZone>>(ceil((MAX_ALT + 1500f) / VERT_SEP).roundToInt() - startingAltitude / VERT_SEP) {
        GdxArray()
    }

    /**
     * Checks wake separation infringement for the input entities, and adds any conflicts found to the input conflict
     * list
     * @param conflictAbles array of all the entities that should be checked for conflicts
     * @param currentConflicts the current list of conflicts already found in this update
     */
    fun checkWakeConflicts(conflictAbles: ImmutableArray<Entity>, currentConflicts: GdxArray<Conflict>) {
        conflictAbles.forEach {
            val pos = it[Position.mapper] ?: return@forEach
            val alt = it[Altitude.mapper] ?: return@forEach
            val acInfo = it[AircraftInfo.mapper] ?: return@forEach
            val wakeTolerance = it[WakeTolerance.mapper] ?: return@forEach
            // We will not check wake separation for aircraft that have just taken off
            if (it.has(TakeoffClimb.mapper)) return@forEach

            /**
             * Checks whether the current aircraft in the context has infringed wake separation for wake zones in the
             * input sector level
             * @param sector the level sector containing wake zones to check
             * @return true if aircraft is infringing on wake zones, else false
             */
            fun checkWakeConflictForAircraftInSector(sector: GdxArray<WakeZone>): Boolean {
                for (i in 0 until sector.size) sector[i]?.apply {
                    val wakeInfo = entity[WakeInfo.mapper] ?: return@apply
                    val wakeAlt = entity[Altitude.mapper] ?: return@apply
                    // Check wake is not being generated by self
                    if (acInfo.icaoCallsign == wakeInfo.aircraftCallsign) return@apply

                    // Check for wake inhibition
                    val currApp = it[GlideSlopeCaptured.mapper]?.gsApp ?: it[LocalizerCaptured.mapper]?.locApp
                    ?: it[VisualCaptured.mapper]?.parentApp ?: it[CirclingApproach.mapper]?.let { cir ->
                        if (cir.phase >= 1) cir.circlingApp else null
                    }
                    val appWakeInhibit = currApp?.get(WakeInhibit.mapper)?.approachNames
                    val arrivalAirportId = it[ArrivalAirport.mapper]?.arptId
                    if (arrivalAirportId != null && arrivalAirportId == wakeInfo.approachAirportId
                        && appWakeInhibit?.contains(wakeInfo.approachName) == true) return@apply

                    // Check that aircraft altitude is between 90 feet above and 950 feet below the wake altitude
                    if (alt.altitudeFt > wakeAlt.altitudeFt + 90 || alt.altitudeFt < wakeAlt.altitudeFt - 950) return@apply
                    // Check that distance of the wake zone is smaller than required separation
                    val reqDist = WakeMatrix.getDistanceRequired(wakeInfo.leadingWake, wakeInfo.leadingRecat,
                        acInfo.aircraftPerf.wakeCategory, acInfo.aircraftPerf.recat)

                    // Check if aircraft is physically inside the wake zone
                    if (!contains(pos.x, pos.y)) return@apply

                    // Calculate distance of leader aircraft from its first wake point
                    val frontAc = GAME.gameServer?.aircraft?.get(wakeInfo.aircraftCallsign)?.entity
                    val frontAcPos = frontAc?.get(Position.mapper)
                    val frontAcTrail = frontAc?.get(WakeTrail.mapper)?.wakeZones
                    val firstPointPos = if (frontAcTrail?.isEmpty == false) frontAcTrail[0].first else null
                    val frontAcDistNmFromFirstWakePoint = if (frontAcPos != null && firstPointPos != null) {
                        pxToNm(calculateDistanceBetweenPoints(frontAcPos.x, frontAcPos.y, firstPointPos.x, firstPointPos.y))
                    } else 0f

                    // Calculate distance of follower aircraft from the wake zone start
                    val distNmFromWakeStart = entity[Position.mapper]?.let { wakePos ->
                        // All new wake zones >= build 17 will have the position component
                        pxToNm(calculateDistanceBetweenPoints(pos.x, pos.y, wakePos.x, wakePos.y))
                    } ?: entity[GPolygon.mapper]?.vertices?.let { vertices ->
                        // For older wake zones without position component, use vertices to estimate
                        val startX = (vertices[4] + vertices[6]) / 2
                        val startY = (vertices[5] + vertices[7]) / 2
                        pxToNm(calculateDistanceBetweenPoints(pos.x, pos.y, startX, startY))
                    } ?: 0f

                    val totalDist = wakeInfo.distFromAircraft + frontAcDistNmFromFirstWakePoint + distNmFromWakeStart
                    val infringeDist = totalDist - reqDist
                    if (infringeDist < 0) {
                        wakeTolerance.accumulation -= infringeDist
                        return true
                    }
                }
                return false
            }

            // Get the sector this aircraft belongs to
            val sector = getSectorIndexForAlt(alt.altitudeFt, startingAltitude)

            // Check wake zones in this sector
            if (sector >= 0 && sector < wakeLevels.size && checkWakeConflictForAircraftInSector(wakeLevels[sector])) {
                currentConflicts.add(Conflict(it, null, null, 3f, Conflict.WAKE_INFRINGE))
                return@forEach
            }

            // Check wake zones in the sector above
            if (sector + 1 >= 0 && sector + 1 < wakeLevels.size && checkWakeConflictForAircraftInSector(wakeLevels[sector + 1])) {
                currentConflicts.add(Conflict(it, null, null, 3f, Conflict.WAKE_INFRINGE))
                return@forEach
            }

            // If no conflicts found, reduce wake accumulation by 2
            wakeTolerance.accumulation = (wakeTolerance.accumulation - 2).coerceAtLeast(0f)
        }
    }

    /**
     * Adds a wake zone to the respective wake level array, based on its wake altitude
     * @param wakeZone the wake zone to add
     */
    fun addWakeZone(wakeZone: WakeZone) {
        val alt = wakeZone.entity[Altitude.mapper] ?: return
        val sectorIndex = getSectorIndexForAlt(alt.altitudeFt, startingAltitude)
        if (sectorIndex >= 0 && sectorIndex < wakeLevels.size) wakeLevels[sectorIndex].add(wakeZone)
    }

    /**
     * Removes the input wake zone from its respective wake level array
     * @param wakeZone the wake zone to add
     */
    fun removeWakeZone(wakeZone: WakeZone) {
        val alt = wakeZone.entity[Altitude.mapper] ?: return
        val sectorIndex = getSectorIndexForAlt(alt.altitudeFt, startingAltitude)
        if (sectorIndex >= 0 && sectorIndex < wakeLevels.size) wakeLevels[sectorIndex].removeValue(wakeZone, true)
    }
}