package com.bombbird.terminalcontrol2.traffic

import com.badlogic.ashley.core.Entity
import com.badlogic.ashley.utils.ImmutableArray
import com.bombbird.terminalcontrol2.components.AircraftInfo
import com.bombbird.terminalcontrol2.components.Altitude
import com.bombbird.terminalcontrol2.components.Position
import com.bombbird.terminalcontrol2.components.WakeInfo
import com.bombbird.terminalcontrol2.entities.WakeZone
import com.bombbird.terminalcontrol2.global.MAX_ALT
import com.bombbird.terminalcontrol2.global.VERT_SEP
import ktx.ashley.get
import ktx.collections.GdxArray
import kotlin.math.ceil
import kotlin.math.floor
import kotlin.math.roundToInt

/** Helper class for managing wake separation between entities */
class WakeManager {

    private val startingAltitude = floor(getLowestAirportElevation() / VERT_SEP).roundToInt() * VERT_SEP
    val wakeLevels = Array<GdxArray<WakeZone>>(ceil((MAX_ALT + 1500f) / VERT_SEP).roundToInt() - startingAltitude / VERT_SEP) {
        GdxArray()
    }

    /**
     * Checks wake separation infringement for the input entities, and adds any conflicts found to the input conflict
     * list
     * @param conflictAbles array of all the entities that should be checked for conflicts
     * @param currentConflicts the current list of conflicts already found in this update
     */
    fun checkWakeConflicts(conflictAbles: ImmutableArray<Entity>, currentConflicts: GdxArray<ConflictManager.Conflict>) {
        conflictAbles.forEach {
            val pos = it[Position.mapper] ?: return@forEach
            val alt = it[Altitude.mapper] ?: return@forEach
            val acInfo = it[AircraftInfo.mapper] ?: return@forEach

            /**
             * Checks whether the current aircraft in the context has infringed wake separation for wake zones in the
             * input sector level
             * @param sector the level sector containing wake zones to check
             * @return true if aircraft is infringing on wake zones, else false
             */
            fun checkWakeConflictForAircraftInSector(sector: GdxArray<WakeZone>): Boolean {
                for (i in 0 until sector.size) sector[i]?.apply {
                    val wakeInfo = entity[WakeInfo.mapper] ?: return@apply
                    val wakeAlt = entity[Altitude.mapper] ?: return@apply
                    // Check wake is not being generated by self
                    if (acInfo.icaoCallsign == wakeInfo.aircraftCallsign) return@apply
                    // Check that aircraft altitude is between 25 feet above and 950 feet below the wake altitude
                    if (alt.altitudeFt > wakeAlt.altitudeFt + 25 || alt.altitudeFt < wakeAlt.altitudeFt - 950) return@apply
                    // Check that distance of the wake zone is smaller than required separation
                    val reqDist = WakeMatrix.getDistanceRequired(wakeInfo.leadingWake, wakeInfo.leadingRecat,
                        acInfo.aircraftPerf.wakeCategory, acInfo.aircraftPerf.recat)
                    if (reqDist < wakeInfo.distFromAircraft + 0.01f) return@apply
                    // Check if aircraft is physically inside the wake zone; if so, add to the list of conflicts and skip
                    // all remaining wake zones
                    if (contains(pos.x, pos.y)) return true
                }
                return false
            }

            // Get the sector this aircraft belongs to
            val sector = getSectorIndexForAlt(alt.altitudeFt, startingAltitude)

            // Check wake zones in this sector
            if (sector >= 0 && sector < wakeLevels.size && checkWakeConflictForAircraftInSector(wakeLevels[sector])) {
                currentConflicts.add(ConflictManager.Conflict(it, null, null, 3f, ConflictManager.Conflict.WAKE_INFRINGE))
                return@forEach
            }

            // Check wake zones in the sector above
            if (sector + 1 >= 0 && sector + 1 < wakeLevels.size && checkWakeConflictForAircraftInSector(wakeLevels[sector + 1]))
                currentConflicts.add(ConflictManager.Conflict(it, null, null, 3f, ConflictManager.Conflict.WAKE_INFRINGE))
        }
    }

    /**
     * Adds a wake zone to the respective wake level array, based on its wake altitude
     * @param wakeZone the wake zone to add
     */
    fun addWakeZone(wakeZone: WakeZone) {
        val alt = wakeZone.entity[Altitude.mapper] ?: return
        val sectorIndex = getSectorIndexForAlt(alt.altitudeFt, startingAltitude)
        if (sectorIndex >= 0 && sectorIndex < wakeLevels.size) wakeLevels[sectorIndex].add(wakeZone)
    }

    /**
     * Removes the input wake zone from its respective wake level array
     * @param wakeZone the wake zone to add
     */
    fun removeWakeZone(wakeZone: WakeZone) {
        val alt = wakeZone.entity[Altitude.mapper] ?: return
        val sectorIndex = getSectorIndexForAlt(alt.altitudeFt, startingAltitude)
        if (sectorIndex >= 0 && sectorIndex < wakeLevels.size) wakeLevels[sectorIndex].removeValue(wakeZone, true)
    }
}